grammar de.wwu.md2.framework.MD2 with org.eclipse.xtext.common.Terminals

generate mD2 "http://www.wwu.de/md2/framework/MD2"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


/////////////////////////////////////
/////////////////////////////////////
// Initial
/////////////////////////////////////
/////////////////////////////////////

/*
 * The MD2Model is the root element of each model.
 * It contains the package definition and model
 * layer in the layer specific type.
 */
MD2Model:
	// Each model layer has to be stored in a
	// corresponding package (see constraints)
	package = PackageDefinition
	modelLayer = MD2ModelLayer?
;

/*
 * The MD2ModelLayer can be either a View,
 * a Controller or a Model
 */
MD2ModelLayer:
	View | Controller | Model | Workflow
;

/*
 * The PackageDefinition contains the
 * package name as fully qualified name.
 */
PackageDefinition:
	'package' pkgName = QUALIFIED_NAME
;


/////////////////////////////////////
/////////////////////////////////////
// View layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root View element contains all
 * ViewElements of this view model.
 */
View:
	 viewElements += ViewElement+
;

/*
 * A ViewElement can be either a ViewElementType or a style.
 * Styles can only be specified on view level or directly on ViewGUIElement elements,
 * but not within containers. This is why ViewElement and ViewElementType are distinguished.
 */
ViewElement:
	ViewElementType | Style
;

/*
 * The ViewElementType allows to either specify a new ViewGUIElement or to refer to an existing one.
 * All elements of this type are allowed to be used in containers.
 */
ViewElementType:
	ViewGUIElement | ViewGUIElementReference
;

/*
 * A ViewGUIElement is a concrete definition (i.e., no cross-reference to another ViewGUIElement) of arbitrary view elements.
 * It is the super type for ContainerElement and ContentElement. After the pre-processing all elements of type ViewElementType can
 * be assumed to be ViewGUIElements.
 */
ViewGUIElement:
	ContainerElement | ContentElement
;


/////////////////////////////////////
// View layer => Content elements
/////////////////////////////////////

/*
 * ContentElements are all those elements of a view that donÂ´t contain any
 * nested view elements. They are basically used to present data and
 * information to the user or collect data from the user.
 */
ContentElement:
	InputElement | Image | AutoGeneratedContentElement |
	Spacer | Button | Label | Tooltip | UploadedImageOutput
;

InputElement:
	BooleanInput | TextInput | IntegerInput | NumberInput | DateInput |
	TimeInput | DateTimeInput | OptionInput | EntitySelector | FileUpload
;

/*
 * MappableContentElement is a common super type of all GUI elements that
 * can be mapped to contentProviders (multi-inheritance).
 * E.g. useful for validation and auto-completion suggestions.
 */
MappableContentElement:
	InputElement | Label | Tooltip
;

/*
 * TextInputs are basically used to provide the user the possibility to insert data.
 *
 * Using the 'type' attribute the type of the input field can be be specified
 * currently supported => input, textarea and password; if no type is set, DEFAULT is used implicitly.
 * The default is assumed to be 'input' on all platforms.
 *
 * TODO add further options to support different input keyboards for e.g. telephone numbers, emails etc.
 */
TextInput:
	'TextInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = TextInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = STRING)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of TextInputs.
 */
enum TextInputType:
	DEFAULT = 'default' | INPUT = 'input' | TEXTAREA = 'textarea' | PASSWORD = 'password'
;

/*
 * BooleanInputs allow the user to set boolean values.
 * Depending on the platform a boolean input can be a checkbox,
 * a switch etc.
 */
BooleanInput:
	'BooleanInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = BooleanInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = ('true' | 'false'))? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of BooleanInputs.
 * By now only default is supported as the representation of actual boolean
 * inputs is highly platform dependent and MD2 seeks not to violate the design
 * guidelines of the different platforms.
 */
enum BooleanInputType:
	DEFAULT = 'default'
;

/*
 * Integer input field. Depending on the platform this might be a simple validated
 * text input, a number spinner etc.
 */
IntegerInput:
	'IntegerInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = IntegerInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = INT)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of IntegerInputs.
 * If default is set, the input is dependent on the platform. It might be
 * a simple text input that validates that only numbers are entered; a number
 * spinner etc. A text input can be enforced as it is assumed to be supported
 * on all platforms.
 */
enum IntegerInputType:
	DEFAULT = 'default' | INPUT = 'input'
;

/*
 * Float input field. Depending on the platform this might be a simple validated
 * text input or any other specially formatted field.
 */
NumberInput:
	'NumberInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = NumberInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		( placesSet?='places' places=INT)? &
		('default' defaultValue = FLOAT)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of NumberInputs.
 * If default is set, the input is dependent on the platform. It might be
 * a simple text input that validates that only numbers are entered. A
 * text input can be enforced as it is assumed to be supported
 * on all platforms.
 */
enum NumberInputType:
	DEFAULT = 'default' | INPUT = 'input'
;

/*
 * DateInputs allow the user to enter dates.
 * The representation of the actual widget depends on the target platform.
 */
DateInput:
	'DateInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = DateInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = DATE)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of DateInputs.
 * By now only default is supported as the representation of actual date
 * inputs is highly platform dependent and MD2 seeks not to violate the design
 * guidelines of the different platforms.
 */
enum DateInputType:
	DEFAULT = 'default'
;

/*
 * TimeInputs allow the user to enter times.
 * The representation of the actual widget depends on the target platform.
 */
TimeInput:
	'TimeInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = TimeInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = TIME)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of TimeInputs.
 * By now only default is supported as the representation of actual time
 * inputs is highly platform dependent and MD2 seeks not to violate the design
 * guidelines of the different platforms.
 */
enum TimeInputType:
	DEFAULT = 'default'
;

/*
 * DateTimeInputs allow the user to enter an exact point of time.
 * The representation of the actual widget depends on the target platform.
 */
DateTimeInput:
	'DateTimeInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = DateTimeInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = DATE_TIME)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This enumeration contains all possible input types of DateTimeInputs.
 * By now only default is supported as the representation of actual
 * input is highly platform dependent and MD2 seeks to not violate the design
 * guidelines of the different platforms.
 */
enum DateTimeInputType:
	DEFAULT = 'default'
;

/*
 * OptionInputs provide the user the possibility to choose one entry of a list of strings.
 */
OptionInput:
	'OptionInput' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('type' type = OptionInputType)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('default' defaultValue = STRING)? &
		('width' width = PERCENT)? &
		// Optional: Options may be inferred from the mapped model if its data type is an enum
		('options' (enumReference = [Enum] | '{' (enumBody = EnumBody)? '}'))?
	) '}')?
;

/*
 * Possible option input types.
 */
enum OptionInputType:
	DEFAULT = 'default'
;

/*
 * FileInputs enable uploading a file to the application
 */
FileUpload:
	'FileUpload' name = EID ('{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('style' style = StyleAssignment)? &
		('width' width = PERCENT)? &
		('text' buttonValueText = STRING)?
	) '}')?
;

/*
 * The EntitySelector allows the user to select an element from a list of
 * elements. The textProposition defines which ContentProvider stores the
 * list and which attribute of the elements shall be displayed to the user
 * to allow him to find the desired element.
 */
EntitySelector:
	'EntitySelector' name = EID '{' (
		('label' labelText = STRING)? &
		('tooltip' tooltipText = STRING)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('width' width = PERCENT)? &
		('textProposition' textProposition = ContentProviderPath)
	) '}'
;

/*
 * The AutoGeneratedContentElement is bound to a ContentProvider and will automatically create
 * view elements to display all attributes of the related entity. It is possible to either
 * exclude attributes specified with exclude or to provide a positive list of attributes with only.
 * In each case a list of the specified attributes will be stored in filteredAttributes. Which of
 * the two options has been chosen can be determined via exclude.
 */
AutoGeneratedContentElement:
	'AutoGenerator' name = EID '{' (
		('width' width = PERCENT)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		'contentProvider' contentProvider += ContentProviderReference+
			('(' ((exclude ?= 'exclude') | 'only') filteredAttributes += EntityPath+ ')')?
	) '}'
;

/*
 * Buttons provide the user the possibility to call actions,
 * that have been bound on the onTouch event of the Button.
 * This Button specification allows different ways to set the
 * button text (directly or via text attribute).
 */
Button:
	ButtonShorthandDefinition | ButtonExtendedDefinition
;

/*
 * This is the shorthand definition of a Button, where
 * the text will be set in brackets behind the ID
 */
ButtonShorthandDefinition returns Button:
	'Button' name = EID '(' text = STRING ')' ('{' (
		('style' style = StyleAssignment)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This is the extended definition of a Button, where
 * the text will be set as property
 */
ButtonExtendedDefinition returns Button:
	'Button' name = EID '{' (
		'text' text = STRING &
		('style' style = StyleAssignment)? &
		('disabled' ((isDisabled ?= 'true') | 'false'))? &
		('width' width = PERCENT)?
	) '}'
;

/*
 * Tooltips allow the modeler to provide the user with additional
 * information. This Tooltip specification allows different ways
 * to set the help text (directly or via text attribute)
 */
Tooltip:
	TooltipShorthandDefinition | TooltipExtendedDefinition
;

/*
 * This is the shorthand definition of a Tooltip, where
 * the image source will be set in brackets behind the ID
 */
TooltipShorthandDefinition returns Tooltip:
	'Tooltip' name = EID '(' text = STRING ')' ('{'
		('width' width = PERCENT)?
	'}')?
;

/*
 * This is the extended definition of a Tooltip, where
 * the image source will be set as property
 */
TooltipExtendedDefinition returns Tooltip:
	'Tooltip' name = EID '{' (
		'text' text = STRING &
		('width' width = PERCENT)?
	) '}'
;

/*
 * Images allow the modeler to specify and display images to the user.
 * This Image specification allows different ways to set the
 * image source (directly or via src attribute)
 */
Image:
	ImageShorthandDefinition | ImageExtendedDefinition
;

/*
 * This is the shorthand definition of a Image, where
 * the image source will be set in brackets behind the ID
 */
ImageShorthandDefinition returns Image:
	'Image' name = EID '(' src = STRING ')' ('{' (
		('imgHeight' imgHeight = INT)? &
		('imgWidth' imgWidth = INT)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This is the extended definition of a Image, where
 * the image source will be set as property
 */
ImageExtendedDefinition returns Image:
	'Image' name = EID '{' (
		'src' src = STRING &
		('height' height = INT)? &
		('width' width = INT)?
	) '}'
;


/*
 * ImageUploadOutput allow the modeler to specify and display images to the user
 * which were previously uploaded to the backend (using a FileUpload element).
 */
UploadedImageOutput:
	'UploadedImageOutput' name = EID ('{' (
		('imgHeight' imgHeight = INT)? &
		('imgWidth' imgWidth = INT)? &
		('width' width = INT)?
	) '}')?
;

/*
 * Labels allow the modeler to present text to the user.
 * Normally they are used to denote input elements. This
 * Label specification allows different ways to set the
 * label text (directly or via text attribute)
 */
Label:
	LabelShorthandDefinition | LabelExtendedDefinition
;

/*
 * This is the shorthand definition of a Label, where
 * the text will be set in brackets behind the ID
 */
LabelShorthandDefinition returns Label:
	'Label' name = EID '(' text = STRING ')' ('{' (
		('style' style = StyleAssignment)? &
		('width' width = PERCENT)?
	) '}')?
;

/*
 * This is the extended definition of a Label, where
 * the text will be set as property
 */
LabelExtendedDefinition returns Label:
	'Label' name = EID '{' (
		'text' text = STRING &
		('style' style = StyleAssignment)? &
		('width' width = PERCENT)?
	) '}'
;

/*
 * A Spacer is used in a GridLayoutPane to mark an empty
 * cell or in a FlowLayoutPane to occupy some space.
 */
Spacer:
	// Hack to force the spacer to have a name attribute in the inferred model
	// the __Dummy keyword will be suppressed in auto completion and via validator
	'Spacer' ({Spacer} ('(' 'number'? number = INT? ')')? | '__Dummy' name = ID) ('{'
		('width' width = PERCENT)?
	'}')?
;


/////////////////////////////////////
// View layer => Container elements
/////////////////////////////////////

/*
 * ContainerElements are used to composite ViewGUIElements.
 */
ContainerElement:
	ContentContainer | SubViewContainer
;

/*
 * ContentContainers can contain other Containers or ContentElements.
 */
ContentContainer:
	GridLayoutPane | FlowLayoutPane | ActionDrawer | ListView
;

/*
 * SubViewContainers can only contain other Containers. The containers in SubViewContainers have the role of
 * sub views, i.e. only one container is shown at any time and by changing the view only the containing elements
 * are replaced.
 */
SubViewContainer:
	AlternativesPane | TabbedAlternativesPane
;

/*
 * A ListView for using a whole Activity as a List
 */
 ListView:
 	'ListView' name = EID ('(' params += ListViewLayoutParam (',' params += ListViewLayoutParam)* ')')? '{'
 		('connectedProvider' connectedProvider = ContentProviderPath)
 		('onClickAction' onClickAction = [Action | QUALIFIED_NAME])?
 		('leftSwipeAction' leftSwipeAction = [Action | QUALIFIED_NAME])?
 		('rightSwipeAction' rightSwipeAction = [Action | QUALIFIED_NAME])?
 		elements += ViewElementType* 
 	'}'
 ;
ListViewParam:
	{PlaceholderParam} 'placeholder' value = INT
;

ListViewLayoutParam:
	{ViewIcon} 'icon' value = ViewIcon?
;

ViewIcon:
	"ic_add_shopping_cart_white_24dp" | "ic_shopping_cart_white_24dp" | "ic_remove_shopping_cart_white_24dp" | "ic_add_circle_outline_white_24dp" | "ic_build_white_24dp" | "ic_flare_white_24dp" | "ic_add_circle_white_24dp" |
	"ic_add_box_white_24dp" |"ic_remove_circle_white_24dp" |"ic_create_white_24dp"|"ic_clear_white_24dp"|"ic_help_white_24dp"|"ic_lightbulb_outline_white_24dp"
;

ViewIconActionDrawer:
	ViewIcon//"ic_shopping_cart_white_24dp" | "ic_remove_shopping_cart_white_24dp" | "ic_add_circle_white_24dp" | "ic_add_shopping_cart_white_24dp"
;

/*
 * A GridLayoutPane allows the arrangement of ViewGUIElements in a grid structure. The user can specify the
 * number of columns or the number of rows. If one of those is specified the other one will be calculated by
 * MD2. If both are specified and the resulting number of cells is smaller than the number of contained
 * elements, the exceeding elements will be ignored.
 */
GridLayoutPane:
	'GridLayoutPane' name = EID '(' params += GridLayoutPaneParam (',' params += GridLayoutPaneParam)* ')' '{'
		elements += ViewElementType*
	'}'
;

/*
 * The GridLayoutPaneParam specifies all possible parameters for a GridLayoutPane.
 * These are besides the number of columns and rows all TabSpecificParams.
 */
GridLayoutPaneParam:
	{GridLayoutPaneColumnsParam} 'columns' value = INT | {GridLayoutPaneRowsParam} 'rows' value = INT | CommonContainerParam | {ViewIcon} 'icon' value = ViewIcon? 
;

/*
 * A FlowLayoutPane allows the arrangement of ViewGUIElements one after another either horizontally or vertically.
 */
FlowLayoutPane:
	'FlowLayoutPane' name = EID ('(' (params += FlowLayoutPaneParam (',' params += FlowLayoutPaneParam)*)? ')')? '{'
		elements += ViewElementType*
	'}'
;

/*
 * The FlowLayoutPaneParam specifies all possible parameters for a FlowLayoutPane.
 * These are besides the flowDirection all TabSpecificParams.
 */
FlowLayoutPaneParam:
	{FlowLayoutPaneFlowDirectionParam} flowDirection = FlowDirection | CommonContainerParam | {ViewIcon} 'icon' value = ViewIcon? //{ViewIcon} 'icon' value = ("close_button"|"common_full_open_on_phone"|"common_google_signin_btn_icon_light")?
;

/*
 * The FlowDirection lists all possible orientations that can be used
 * to define the flow of elements contained in a FlowLayoutPane
 */
enum FlowDirection:
	HORIZONTAL = 'horizontal' | VERTICAL = 'vertical'
;

/* An Action Drawer allows the arrangement of ViewGUIElements in a menu structure. The user can add Buttons
 * or Labels in a single-column view structure.
 */
ActionDrawer:
	'ActionDrawer' name = EID ('('(params += ActionDrawerParam (',' params += ActionDrawerParam)*)?')')? '{'

	 'Actions' '{'
	 	onItemClickAction += [Action | QUALIFIED_NAME] (',' onItemClickAction += [Action | QUALIFIED_NAME ])*
	 '}'

	 elements += ViewElementType*
	  '}'
;

ActionDrawerParam:
	{ActionDrawerBezeichnung} 'ActionDrawerTitel' value = STRING |
	{ActionDrawerTitleParam} 'Actions_titels' ('('(values += STRING (',' values += STRING)*)?')') | //STRING |
	{ViewIconActionDrawer} 'Actions_icons' ('('(values += ViewIconActionDrawer(',' values += ViewIconActionDrawer)*)?')')
;

/*
 * The AlternativesPane allows the definition of several ContainerElements of which one will be
 * shown to the user. The user will be able to choose which ContainerElement shall be displayed.
 */
AlternativesPane:
	'AlternativesPane' name = EID  ('(' (params += CommonContainerParam (',' params += CommonContainerParam)*)? ')')? '{'
		elements += ContainerElementType*
	'}'
;

/*
 * The TabbedAlternativesPane is a special AlternativesPane that
 * allows the user to switch between tabs by offering him a tab bar.
 */
TabbedAlternativesPane:
	'TabbedPane' name = EID ('(' ')')? '{'
		elements += ContainerElementType*
	'}'
;

/*
 * CommonContainerParams are parameters that can be applied to all container elements.
 * That can either be a TabSpecificParam or a width parameter that defines the width
 * of a container relative to its parent element.
 */
CommonContainerParam:
	{WidthParam} 'width' width = PERCENT | TabSpecificParam
;

/*
 * TabSpecificParam defines the parameters the user can set to a
 * ContainerElement that is contained in a TabbedAlternativesPane.
 */
TabSpecificParam:
	{TabTitleParam} 'tabTitle' tabTitle = STRING | {TabIconParam} 'tabIcon' tabIcon = STRING
;

/////////////////////////////////////////
// View layer => ViewElementReferences
/////////////////////////////////////////

/*
 * A reference to another GUI element. All references will be replaced by its concrete instances during
 * preprocessing. By renaming a reference, the later cloned element can be accessed by the new name, e.g.
 * for mapping, validator binding etc. So, the reference is treated as if it were the actual GUI element.
 */
ViewGUIElementReference:
	value = [ViewGUIElement | QUALIFIED_NAME] (rename ?= '->' name = EID)?
;

/*
 * Each ContainerElementReference is a special case of the ViewGUIElementReference that is meant to be used
 * in SubViewContainers (TabbedPane, AlternativesPane).
 */
ContainerElementReference returns ViewGUIElementReference:
	{ContainerElementReference} value = [ContainerElement | QUALIFIED_NAME] (rename ?= '->' name = EID)? ('(' (params += TabSpecificParam (',' params += TabSpecificParam)*)? ')')?
;

/*
 * The ContainerElementType allows to either specify a new ContainerElement or to refer to an existing one.
 * Used in SubViewContainers (TabbedPane, AlternativesPane).
 */
ContainerElementType:
	ContainerElement | ContainerElementReference
;


/////////////////////////////////////////
// View layer => Style definitions
/////////////////////////////////////////

/*
 * The StyleAssignment allows the user to
 * either define a new Style or to refer
 * to an existing one.
 */
StyleAssignment:
	{StyleDefinition} definition = StyleBody |
	{StyleReference} reference = [Style]
;

/*
 * A Style allows the user to define a
 * new Style in the StyleBody and allow
 * the reference to it by defining a name.
 */
Style:
	'style' name = EID
	body = StyleBody
;

/*
 * The StyleBody contains the actual style and can be used to set the appearance of the text of some
 * ViewGUIElements. It is possible to set the fontSize, the color and the textStyle.
 * The fontSize is relative to the default font size, i.e. similar to the unit <i>em</i> in CSS.
 * 1em is equal to the current font size. 2em means 2 times the size of the current font. This way,
 * it can adapt automatically to the font size that the target device uses. If the target platform does not
 * support <i>em</i> as a unit, the pixel or pt size can easily be calculated.
 */
StyleBody:
	'{' {StyleBody} (
		('fontSize' fontSize = FLOAT)? &
		('color' color = Color)? &
		('textStyle' ((bold?='bold'? & italic?='italic'?) | 'normal'))?
	) '}'
;

/*
 * A Color can be either specified
 * as HEX_COLOR or NamedColor.
 *
 * Notice:
 * Preprocessing replaces all NamedColors
 * by their hex color equivalents.
 */
Color:
	{HexColorDef} color = HEX_COLOR |
	{NamedColorDef} color = NamedColor
;

/**
 * NamedColor contains the set of the 16 named web colors as specified in HTML 4.01.
 */
enum NamedColor:
	AQUA = 'aqua' | BLACK = 'black' | BLUE = 'blue' | FUCHSIA = 'fuchsia' |
	GRAY = 'gray' | GREEN = 'green' | LIME = 'lime' | MAROON = 'maroon' |
	NAVY = 'navy' | OLIVE = 'olive' | PURPLE ='purple' | RED = 'red' |
	SILVER = 'silver' | TEAL = 'teal' | WHITE = 'white' | YELLOW = 'yellow'
;


/////////////////////////////////////
/////////////////////////////////////
// Controller layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root Controller element contains all
 * ControllerElements containing to this view Controller
 */
Controller:
	 controllerElements += ControllerElement+
;

/*
 * The ControllerElement is the super type of all possible ControllerElements.
 */
ControllerElement:
	ContentProvider | Validator | Main | RemoteConnection | WorkflowElement | WebServiceCall
;


/////////////////////////////////////
// Controller layer => WorkflowElements
/////////////////////////////////////

/*
 * WorkflowElements are controllers for encapsulated functionality.
 * The onInit block is performed on initialization of the workflowelement
 */
WorkflowElement:
	'WorkflowElement' name=EID '{'

		('defaultProcessChain' defaultProcessChain = [ProcessChain]

		'onInit' '{'
            initActions += [Action] (',' initActions += [Action])*
		'}')

		((actions += Action*) &
		(processChain += ProcessChain+) &
		(invoke += InvokeDefinition*))

	'}'
;





/////////////////////////////////////
// Controller layer => Events
/////////////////////////////////////

/*
 * An Action provides the user the possibility to
 * declare a set of tasks. An Action can be
 * either a CustomAction or a CombinedAction.
 */
Action:
	'action'
		(CustomAction | CombinedAction)
;

/*
 * A CustomAction contains a list of CustomCodeFragments
 * where each CustomCodeFragment contains one task.
 */
CustomAction:
	'CustomAction' name = EID '{'
		codeFragments += CustomCodeFragment*
	'}'
;

/*
 * CombinedActions allow the composition of Actions.
 */
CombinedAction:
	'CombinedAction' name = EID '{'
		actions += [Action | QUALIFIED_NAME]*
	'}'
;

/*
 * SimpleActions are simple tasks that can be used by the user to declare operations that the app shall perform.
 */
SimpleAction:
	// virtual actions that are replaced during preprocessing
	{ProcessChainProceedAction} 'ProcessChainProceed' |
	{ProcessChainReverseAction} 'ProcessChainReverse' |
	{ProcessChainGotoAction} 'ProcessChainGoto' '(' pcStep = [ProcessChainStep | QUALIFIED_NAME] ')' |
	{SetProcessChainAction} 'SetProcessChain' '(' processChain = [ProcessChain] ')' |

	// core actions that have to be supported by the platform
	{GotoViewAction} ('GotoView' '(' view = AbstractViewGUIElementRef ')' ) |
	{DisableAction} ('Disable' '(' inputField = AbstractViewGUIElementRef ')' ) |
	{EnableAction} ('Enable' '(' inputField = AbstractViewGUIElementRef ')' ) |
	{DisplayMessageAction} ('DisplayMessage' '(' message = SimpleExpression ')' ) |
	{ContentProviderOperationAction} ('ContentProviderOperation' '(' operation = AllowedOperation contentProvider = AbstractProviderReference ')') |
	{ContentProviderResetAction} ('ContentProviderReset' '('contentProvider = ContentProviderReference ')') |
	{FireEventAction} ('FireEvent' '('workflowEvent = WorkflowEvent')') |
	{WebServiceCallAction} ('WebServiceCall' webServiceCall = [WebServiceCall]) |
	{LocationAction} ('Location' '('
			'inputs' '(' ('cityInput' cityInput=AbstractContentProviderPath
						 &'streetInput' streetInput=AbstractContentProviderPath
						 &('streetNumberInput' streetNumberInput=AbstractContentProviderPath)?
						 &'postalInput' postalInput=AbstractContentProviderPath
						 &'countryInput' countryInput=AbstractContentProviderPath)
					 ')'
			'outputs' '('
			('latitudeOutput' latitude=AbstractContentProviderPath
			&'longitudeOutput' longitude=AbstractContentProviderPath) ')' ')' ) |

	//supported Actions for multi-valued ContentProviders
	{ContentProviderAddAction} ('ContentProviderAdd' '('contentProviderTarget = ContentProviderReference  ','  contentProviderSource = ContentProviderReference ')') |
	{ContentProviderGetActiveAction} ('ContentProviderGetActive' '(' contentProviderTarget = ContentProviderReference ',' contentProviderSource = ContentProviderReference')') |
	{ContentProviderRemoveActiveAction} ('ContentProviderRemoveActive' '(' contentProvider = ContentProviderReference ')') |
	
	// TODO -- Support RemoveAction with whereClause
	{ContentProviderRemoveAction} ('ContentProviderRemove' '('contentProvider = ContentProviderReference 'where' whereClause = WhereClauseCondition ')') |
	// TODO -- does not make sense as action; maybe allow getters as follows :contentProviderRef(first where Customer.name equals "John").name
    {ContentProviderGetAction} ('ContentProviderGet' '('contentProvider = AbstractProviderReference ('where' whereClause = WhereClauseCondition)? ')')
;

/////////////////////////////////////
// Controller layer => Custom code
/////////////////////////////////////

/*
 * A CustomCodeFragment defines the possible commands and tasks that can be declared in a CustomAction.
 *
 * TODO define all keywords that are supported by our language
 * TODO provide possibility to implement arbitrary code (in theory)
 */
CustomCodeFragment:
	'bind' (
		{EventBindingTask} ('action' | 'actions') actions += ActionDef+ 'on' events += EventDef+ |
		{ValidatorBindingTask} ('validator' | 'validators') validators += ValidatorType+ 'on' referencedFields += AbstractViewGUIElementRef+ ) |
	'unbind' (
		{EventUnbindTask} ('action' | 'actions') actions += ActionDef+ 'from' events += EventDef+ |
		{ValidatorUnbindTask} ('validator' | 'validators') (validators += ValidatorType+ | allTypes ?= 'all') 'from' referencedFields += AbstractViewGUIElementRef+ ) |
	'call' (
		{CallTask} action = ActionDef ) |
	'map' (
		{MappingTask} referencedViewField = AbstractViewGUIElementRef 'to' pathDefinition = AbstractContentProviderPath ) |
	'unmap' (
		{UnmappingTask} referencedViewField = AbstractViewGUIElementRef 'from' pathDefinition = AbstractContentProviderPath ) |
	'set' (
		 =>ContentProviderPath {AttributeSetTask.pathDefinition=current} '=' source = SimpleExpression |
		ContentProviderReference {ContentProviderSetTask.contentProvider=current} '=' source = SimpleExpression |
		AbstractViewGUIElementRef {ViewElementSetTask.referencedViewField=current} '=' source = SimpleExpression ) |
	'if' (
		{ConditionalCodeFragment} if = IfCodeBlock ('elseif' elseifs += IfCodeBlock)* ('else' else = ElseCodeBlock)? )
;

IfCodeBlock:
	'(' condition = Condition ')' '{' codeFragments += CustomCodeFragment* '}'
;

ElseCodeBlock:
	{ElseCodeBlock} '{' codeFragments += CustomCodeFragment* '}'
;

/*
 * Helper Rule. Each element that can contain codeFragments should inherit from ContainsCodeFragments. So, the code of the generators and
 * the preprocessing does not have to be adapted each time a new element that has a codeFragments attribute is added.
 */
ContainsCodeFragments:
	CustomAction | IfCodeBlock | ElseCodeBlock
;

/*
 * The AbstractViewGUIElementRef allows to reference any defined ViewGUIElement.
 * First a top level element has to be defined in ref. In tail a recursive navigation
 * to nested elements can be specified. If the last tail points to an
 * AutoGeneratedContentElement path or simpleType can be used to navigate inside the
 * Entity, the ContentProvider is bound on. This will be a reference to the auto
 * generated ViewGUIElement containing the value of the specified Attribute.
 */
AbstractViewGUIElementRef:
	ref = [ViewElementType | QUALIFIED_NAME] (
		tail = NestedAbstractViewGUIElementRef |
		'[' (path = EntityPath | simpleType = SimpleDataTypeWrapper) ']'
	)?
;

/*
 * The NestedAbstractViewGUIElementRef allows to point to an ViewGUIElement
 * nested in another ViewGUIElement. In tail a recursive navigation
 * to nested elements can be specified. If the last tail points to an
 * AutoGeneratedContentElement path or simpleType can be used to navigate inside the
 * Entity, the ContentProvider is bound on. This will be an reference to the auto
 * generated ViewGUIElement containing the value of the specified Attribute.
 *
 * A NestedAbstractViewGUIElementRef will result in an AbstractViewGUIElementRef.
 * The difference and reason, why the NestedAbstractViewGUIElementRef is needed,
 * is that AbstractViewGUIElementRef can just point to top level ViewGUIElements
 * while NestedAbstractViewGUIElementRef can point to nested ViewGUIElements.
 * This is important, if a ViewGUIElement referred in a ContainerElement
 * shall be referenced.
 */
NestedAbstractViewGUIElementRef returns AbstractViewGUIElementRef:
	'->' ref = [ViewElementType | QUALIFIED_NAME] (
		tail = NestedAbstractViewGUIElementRef |
		'[' (path = EntityPath | simpleType = SimpleDataTypeWrapper) ']'
	)?
;

/*
 * The ActionDef allows the user to either define a new Action or
 * directly a SimpleAction
 */
ActionDef:
	{ActionReference} actionRef = [Action | QUALIFIED_NAME] |
	{SimpleActionRef} action = SimpleAction
;

/*
 * The EventDef allows the user to refer to one of the four possible event types.
 */
EventDef:
	=>AbstractContentProviderPath {ContentProviderPathEventRef.pathDefinition=current} '.' event = ContentProviderEventType |
	AbstractProviderReference {ContentProviderEventRef.contentProvider=current} '.' event = ContentProviderEventType |
	{ViewElementEventRef} referencedField = AbstractViewGUIElementRef '.' event = ElementEventType |
	{GlobalEventRef} event = GlobalEventType |
	{ConditionalEventRef} eventReference = [OnConditionEvent | QUALIFIED_NAME]
;

/*
 * ElementEventType lists all possible events that are supported by ViewGUIElements.
 */
enum ElementEventType:
	ON_CLICK = "onClick" |
	ON_LONG_CLICK = "onLongClick" |
	ON_CHANGE = "onChange" |
	ON_LEFT_SWIPE = "onLeftSwipe" |
	ON_RIGHT_SWIPE = "onRightSwipe" |
	ON_WRONG_VALIDATION = "onWrongValidation"
;

/*
 * ContentProviderEventType lists all possible
 * events supported by ContentProviders
 */
enum ContentProviderEventType:
	ON_CHANGE = "onChange"
;

/*
 * GlobalEventType lists all possible app wide events.
 */
enum GlobalEventType:
	ON_CONNECTION_LOST = 'onConnectionLost' |
	ON_CONNECTION_REGAINED = 'onConnectionRegained' |
	ON_LOCATION_UPDATE = 'onLocationUpdate'
;


/////////////////////////////////////
// Controller layer => Validators
/////////////////////////////////////

/*
 * The ValidatorType allows to either specify
 * a new Validator or to use a StandardValidator
 */
ValidatorType:
	{CustomizedValidatorType} validator = [Validator | QUALIFIED_NAME] |
	{StandardValidatorType} validator = StandardValidator
;

/*
 * Validator allows to declare one of the supported Validators. Apart from the RemoteValidator, all validators are transformed into
 * StandardValidators during the pre-processing.
 */
Validator:
	'validator' (
		{RegExValidator} 'RegExValidator' name = EID '{' (params += RegExValidatorParam (params += RegExValidatorParam)*) '}' |
		{NotNullValidator} 'NotNullValidator' name = EID '{' (params += ValidatorMessageParam)? '}' |
		{NumberRangeValidator} 'NumberRangeValidator' name = EID '{' (params += NumberRangeValidatorParam (params += NumberRangeValidatorParam)*) '}' |
		{StringRangeValidator} 'StringRangeValidator' name = EID '{' (params += StringRangeValidatorParam (params += StringRangeValidatorParam)*) '}' |
		{DateRangeValidator} 'DateRangeValidator' name = EID '{' (params += DateRangeValidatorParam (params += DateRangeValidatorParam)*) '}' |
		{TimeRangeValidator} 'TimeRangeValidator' name = EID '{' (params += TimeRangeValidatorParam (params += TimeRangeValidatorParam)*) '}' |
		{DateTimeRangeValidator} 'DateTimeRangeValidator' name = EID '{' (params += DateTimeRangeValidatorParam (params += DateTimeRangeValidatorParam)*) '}' |
		RemoteValidator
	)
;

/*
 * StandardValidator contains all Validators that can be directly assigned to input fields without
 * being defined explicitly before. Each StandardValidator supports a set of parameters to allow
 * to define the behavior of the StandardValidator.
 */
StandardValidator:
	{StandardNotNullValidator} 'NotNullValidator' ('(' (params += ValidatorMessageParam)? ')')? |
	{StandardRegExValidator} 'RegExValidator' '(' params += RegExValidatorParam (',' params += RegExValidatorParam)* ')' |
	{StandardNumberRangeValidator} 'NumberRangeValidator' '(' params += NumberRangeValidatorParam (',' params += NumberRangeValidatorParam)* ')' |
	{StandardStringRangeValidator} 'StringRangeValidator' '(' params += StringRangeValidatorParam (',' params += StringRangeValidatorParam)* ')' |
	{StandardDateRangeValidator} 'DateRangeValidator' '(' params += DateRangeValidatorParam (',' params += DateRangeValidatorParam)* ')' |
	{StandardTimeRangeValidator} 'TimeRangeValidator' '(' params += TimeRangeValidatorParam (',' params += TimeRangeValidatorParam)* ')' |
	{StandardDateTimeRangeValidator} 'DateTimeRangeValidator' '(' params += DateTimeRangeValidatorParam (',' params += DateTimeRangeValidatorParam)* ')'
;

/*
 * The RemoteValidator allows to use a Validator offered by the backend server.
 *
 * By default only the content and id of the field on which the RemoteValidator has been assigned
 * are transmitted to the backend server. However, additional information can be provided using the
 * provideModel or provideAttributes keyword.
 */
RemoteValidator:
	'RemoteValidator' name = EID '{' (
		(params += ValidatorMessageParam)? &
		('connection' connection = [RemoteConnection])? &
		('model' contentProvider = ContentProviderReference | 'attributes' (provideAttributes += ContentProviderPath)+)
	) '}'
;

/*
 * ValidatorParam is used to define a common super type of all specific ValidatorParams.
 *
 * The ValidatorParam is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
ValidatorParam:
	ValidatorMessageParam | RegExValidatorParam | NumberRangeValidatorParam | StringRangeValidatorParam |
	DateRangeValidatorParam | TimeRangeValidatorParam | DateTimeRangeValidatorParam
;

/*
 * ValidatorMessageParam provides the possibility to define a message, that will be shown to the
 * user if the validation fails.
 */
ValidatorMessageParam:
	'message' message = SimpleExpression
;

/*
 * The RegExValidatorParam allows the definition of a regular
 * expression, that the validator uses to validate the user input.
 * Additionally it contains the ValidatorMessageParam
 */
RegExValidatorParam:
	ValidatorMessageParam | {ValidatorRegExParam} 'regEx' regEx = STRING
;

/*
 * The NumberRangeValidatorParam allows the definition of
 * a numeric range that shall contain the user input.
 * Additionally it contains the ValidatorMessageParam
 */
NumberRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxParam} 'max' max = FLOAT | {ValidatorMinParam} 'min' min = FLOAT
;

/*
 * The StringRangeValidatorParam allows the definition
 * of a string length range. The length of the STRING
 * input by the user will be checked against this range.
 * Additionally it contains the ValidatorMessageParam
 */
StringRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxLengthParam} 'maxLength' maxLength = INT  | {ValidatorMinLengthParam} 'minLength' minLength = INT
;

/*
 * Allows the definition of the earliest / latest valid date.
 * E.g. min "1900-01-01"
 */
DateRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxDateParam} 'max' max = DATE  | {ValidatorMinDateParam} 'min' min = DATE
;

/*
 * Allows the definition of the earliest / latest valid point in time.
 * E.g. min "03:00:00+02:00"
 */
TimeRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxTimeParam} 'max' max = TIME  | {ValidatorMinTimeParam} 'min' min = TIME
;

/*
 * Allows the definition of the earliest / latest valid point in time.
 * E.g. min "1900-01-01T03:00:00+02:00"
 */
DateTimeRangeValidatorParam:
	ValidatorMessageParam | {ValidatorMaxDateTimeParam} 'max' max = DATE_TIME  | {ValidatorMinDateTimeParam} 'min' min = DATE_TIME
;


/////////////////////////////////////
// Controller layer => Main
/////////////////////////////////////

/*
 * The Main object contains all basic information about the collection of apps.
 * Each set of models must contain exactly one Main object.
 */
Main:
	'main' '{'
		(
			('appVersion' appVersion = STRING) &
			('modelVersion' modelVersion = STRING) &
			('workflowManager' workflowManager = [RemoteConnection]) &
			('defaultConnection' defaultConnection = [RemoteConnection])? &
			('fileUploadConnection' fileUploadConnection = [RemoteConnection])?
		)
	'}'
;


/////////////////////////////////////////
// Controller layer => ContentProvider
/////////////////////////////////////////

/*
 * A ContentProvider stores an instance of a ModelElement or a SimpleDataType. It allows to
 * CREATE_OR_UPDATE (save), READ (load) and DELETE (remove) the stored instance. By default all operation
 * are allowed. A filter enables to query a subset of all saved instances. The providerType
 * defines whether the instances shall be stored locally or remotely. The read-only attribute specifies
 * to which fields this content provider can be mapped (if read-only it can only be mapped to none-input fields
 * such as label or tooltip).
 */
ContentProvider:
	'contentProvider' type = DataType name = EID '{' (
		'providerType' (default ?= 'default' | local ?= 'local' | connection = [RemoteConnection]) &
		(filter ?= 'filter' filterType = FilterType ('where' whereClause = WhereClauseCondition)?
		)? &
		('readonly' (readonly ?= 'true' | 'false') | ('polling' (polling ?= 'true' | 'false')))?
	) '}'
;

/*
 * The RemoteConnection allows to specify the connection to a backend server.
 */
RemoteConnection:
	'remoteConnection' name = EID '{' (
		'uri' uri = STRING &
		('password' password = STRING)? &
		('user' user = STRING)? &
		('key' key = STRING)? &
		('storagePath' storagePath=STRING) ?
	) '}'
;

/*
 * DataType allows to refer to an already defined
 * ModelElement or to use a SimpleDataType.
 */
DataType:
	(
		{ReferencedModelType} entity = [ModelElement | QUALIFIED_NAME] |
		{SimpleType} type = SimpleDataType
	) many ?= BRACKETS?
;

/*
 * A SimpleDataTypeWrapper wraps a SimpleDataType.
 * This is used to store the chosen SimpleDataType
 * of the list of possible SimpleDataTypes.
 */
SimpleDataTypeWrapper:
	type = SimpleDataType
;

/*
 * SimpleDataType lists all possible SimpleDataTypes.
 */
enum SimpleDataType:
	INTEGER = 'integer' | FLOAT = 'float' | STRING = 'string' | BOOLEAN = 'boolean' |
	DATE = 'date' | TIME = 'time' | DATE_TIME = 'datetime' | SENSOR = 'sensor'
;

/*
 * AllowedOperation lists all possible AllowedOperations.
 */
enum AllowedOperation:
	CREATE_OR_UPDATE = 'save' | READ = 'load' | DELETE = 'remove'
;

/*
 * The FilterType lists all possible types of filters.
 */
enum FilterType:
	ALL = 'all' | FIRST = 'first'
;


//////////////////////////////////////////////////////////////
// Controller layer => ContentProvider => Filter Conditions
//////////////////////////////////////////////////////////////

/*
 * The WhereClauseCondition allows to composite criteria that
 * have to be fulfilled by instances to be loaded.
 */
WhereClauseCondition:
	WhereClauseOr
;

/**
 * Representation of an arbitrary number of conditional expressions connected by OR.
 * Explicitly model precedence of AND over OR.
 */
WhereClauseOr returns WhereClauseConditionalExpression:
	WhereClauseAnd ({WhereClauseOr.leftExpression=current} OP_CONDITION_OR rightExpression=WhereClauseAnd)*
;

/**
 * Representation of an arbitrary number of conditional expressions connected by AND.
 * Explicitly model precedence of AND over OR.
 */
WhereClauseAnd returns WhereClauseConditionalExpression:
	WhereClauseConditionalExpression ({WhereClauseAnd.leftExpression=current} OP_CONDITION_AND rightExpression=WhereClauseConditionalExpression)*
;

/*
 * The WhereClauseCondition summarizes all possible criteria that
 * have to be fulfilled by instances to be loaded. It resolves to
 * a WhereClauseCondition and is required to allow recursive definition.
 */
WhereClauseConditionalExpression returns WhereClauseConditionalExpression:
	'(' WhereClauseOr ')' |
	{WhereClauseNot} OP_CONDITION_NOT expression = WhereClauseConditionalExpression |
	{WhereClauseCompareExpression} eqLeft = EntityPath op = Operator eqRight = SimpleExpression
;


//////////////////////////////////////////////////////////////
// Controller layer => ContentProvider => References
//////////////////////////////////////////////////////////////

/*
 * Super class for all kind of content providers. Up to now just normal content providers
 * and location content providers are supported.
 */
AbstractProviderReference:
	ContentProviderReference | LocationProviderReference
;

/*
 * A reference to a normal content provider. Never, create direct cross-links to a content provider, as this
 * rule provides the right formatting (colon in front of all content provider references)
 */
ContentProviderReference:
	':' contentProvider = [ContentProvider | QUALIFIED_NAME]
;

/*
 * A 'virtual' content provider that can be used as it were a normal read-only content provider with the name 'location'
 * that provides fields such as street, country etc. The formatting highlights the location keyword as it were a cross-reference.
 */
LocationProviderReference:
	{LocationProviderReference} ':' 'location'
;


//////////////////////////////////////////////////////////////
// Controller layer => ContentProvider => Pathes
//////////////////////////////////////////////////////////////

/*
 * PathDefinition is used to define a common super type of all specific PathDefinitions.
 *
 * The PathDefinition is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
PathDefinition:
	ContentProviderPath | EntityPath
;

/*
 * The EntityPathDefinition defines
 * a path to an attribute of an entity.
 */
EntityPath:
	entityRef = [Entity] tail = PathTail
;

/*
 * Super class for normal content providers and fake content providers such as the location content provider.
 */
AbstractContentProviderPath:
	ContentProviderPath | LocationProviderPath
;

/*
 * The ContentProviderPathDefinition defines a path to an attribute of
 * an entity stored in a ContentProvider.
 */
ContentProviderPath:
	':' contentProviderRef = [ContentProvider] tail = PathTail
;

/*
 * The PathTail defines a recursive list of nested Attribute references.
 */
PathTail:
	'.' attributeRef = [Attribute] (tail = PathTail)?
;

/*
 * The location provider is a fake content provider for location information that is read-only.
 * Thus, it can only be mapped to read-only fields such as labels and tooltips.
 */
LocationProviderPath:
	':' 'location' '.' locationField = LocationField
;

/*
 * The LocationField lists all possible parts of a map/GPS position that are supported.
 */
enum LocationField:
	LATITUDE = 'latitude' | LONGITUDE = 'longitude' | ALTITUDE = 'altitude' | CITY = 'city' | STREET = 'street' |
	NUMBER = 'number' | POSTAL_CODE = 'postalCode' | COUNTRY = 'country' | PROVINCE = 'province'
;


/////////////////////////////////////////
// Controller layer => ProcessChains
/////////////////////////////////////////

/*
 * A ProcessChain is used to define several steps in which the
 * application can currently be. It is possible to define
 * several ProcessChains, ProcessChains can be nested and there
 * is at most one ProcessChain active.
 */
ProcessChain:
	'processChain' name = EID '{'
		processChainSteps += ProcessChainStep*
	'}'
;

/*
 * Each ProcessChainStep defines one view that is related to it
 * and will be displayed if the ProcessChainStep becomes the
 * current ProcessChainStep of the active ProcessChain. Additionally
 * conditions can be defined, that restrict switching to the
 * next or previous ProcessChainStep. Also events can be
 * specified that trigger the change to the next or previous
 * ProcessChainStep. Instead of the former mentioned settings,
 * a ProcessChain can be referred to that will become active
 * while this ProcessChainStep is the current one.
 */
ProcessChainStep:
	'step' name = EID ':' (
		('view' view = AbstractViewGUIElementRef) &
		(gotos += ProcessChainGoToDefinition)* &
		('message' message = SimpleExpression)?
	)
;

ProcessChainGoToDefinition:
	goto = ProcessChainGoTo spec = ProcessChainGoToSpec
;

ProcessChainGoTo:
	{ProcessChainGoToNext} 'proceed' |
	{ProcessChainGoToPrevious} 'reverse' |
	{ProcessChainReturn} 'return' (changeStep ?= 'and' changeDirection = ('proceed' | 'reverse'))? |
	{ProcessChainGoToStep} 'goto' processChainStep = [ProcessChainStep | QUALIFIED_NAME] ('(' 'returnTo' returnTo = [ProcessChainStep | QUALIFIED_NAME] ')')?
;

ProcessChainGoToSpec:
	{ProcessChainGoToSpecShorthand} ('on' events += EventDef+)? |
	{ProcessChainGoToSpecExtended} '{' (
		('on' events += EventDef+)? &
		('given' (condition = Condition | '{' condition = Condition '}'))? &
		('then' action = ActionDef)?
	) '}'
;

/////////////////////////////////////////
// Controller layer => InvokeDefinitions
/////////////////////////////////////////

InvokeDefinition:
	{InvokeDefinition} 'invokable' ('at' path=STRING)? ('using' method=RESTMethod)? ('{'
		(params += InvokeParam+)
	'}')?
;

// Only contentProviderPaths are allowed since LocationProviders are readonly
InvokeParam:
    {InvokeWSParam} field=ContentProviderPath ('as' alias=EID)? |
	{InvokeDefaultValue} 'default' field=ContentProviderPath '=' invokeValue=InvokeValue |
	{InvokeSetContentProvider} 'set' field=ContentProviderPath 'to' (contentProvider= ContentProviderReference)
;

InvokeValue:
	{InvokeStringValue} value=STRING |
	{InvokeIntValue} value=INT |
	{InvokeBooleanValue} value=Boolean |
	{InvokeDateValue} value=DATE |
	{InvokeTimeValue} value=TIME |
	{InvokeDateTimeValue} value=DATE_TIME |
	{InvokeFloatValue} value = FLOAT
;


/////////////////////////////////////////////
// Controller layer => OnConditionEvent
/////////////////////////////////////////////

/*
 * The OnConditionEvent provides the user the possibility
 * to define own events. The OnConditionEvent specifies a
 * Condition. If this Condition is fulfilled, the
 * OnConditionEvent is fired.
 */
OnConditionEvent:
	'event' 'OnConditionEvent' name = EID '{'
		condition = Condition
	'}'
;


/////////////////////////////////////////////
// Controller layer => Condition
/////////////////////////////////////////////


/*
 * A Condition allows to compose ConditionalExpressions with the operators 'not', 'and' and 'or'.
 */
Condition returns ConditionalExpression:
	Or
;

/**
 * Representation of an arbitrary number of conditional expressions connected by OR.
 * Explicitly model precedence of AND over OR.
 */
Or returns ConditionalExpression:
	And ({Or.leftExpression=current} OP_CONDITION_OR rightExpression=And)*
;

/**
 * Representation of an arbitrary number of conditional expressions connected by AND.
 * Explicitly model precedence of AND over OR.
 */
And returns ConditionalExpression:
	ConditionalExpression ({And.leftExpression=current} OP_CONDITION_AND rightExpression=ConditionalExpression)*
;

/*
 * A ConditionalExpression defines an expression that evaluates to either true or false.
 * It is possible to set a BooleanExpression, an EqualsExpression that compares to values,
 * or a GuiElementStateExpression that proofs the state of a ViewGUIElement.
 */
ConditionalExpression:
	('(' Or ')') |
	{Not} OP_CONDITION_NOT expression = ConditionalExpression |
	{BooleanExpression} value = Boolean |
	=>ComplexConditionalExpression
;

ComplexConditionalExpression returns ConditionalExpression:
	=>(AbstractViewGUIElementRef 'is') {GuiElementStateExpression.reference=current} isState = ViewElementState |
	SimpleExpression {CompareExpression.eqLeft=current} op = Operator eqRight = SimpleExpression
;


/*
 * ViewElementState lists all possible ViewElementStates.
 */
enum ViewElementState:
	VALID='valid' | EMPTY='empty' | SET='set' | DEFAULT_VALUE='defaultValue' |
	DISABLED='disabled' | ENABLED='enabled'
;

/*
 * A SimpleExpression contains either a simple data type value of STRING, INT,
 * FLOAT, DATE, TIME, DATE_TIME or a reference to the value of a ViewGUIElement
 * or a reference to an attribute of an entity that is managed by a content provider.
 * Furthermore, it can be a mathematical expression or a string concatenation. Validators
 * have to be implemented to ensure that all assignments match the data type of the
 * target (input field / content provider).
 */
SimpleExpression:
	ConcatenatedString
;


/////////////////////////////////////////////
// Controller Layer =>  Web Services
/////////////////////////////////////////////

WebServiceCall:
    'externalWebService' name=EID '{'
	   ('url' url = STRING &
	   'method' method = RESTMethod &
	   ('queryparams' '('  queryparams += RESTParam* ')')? &
	   ('bodyparams' '(' bodyparams += RESTParam* ')')?)
    '}'
;

RESTParam:
	key = STRING ':' value = RESTValue
;

RESTValue:
    {StringRestParam}       value=STRING |
    {IntegerRestParam}      value=INT |
    {BooleanRestParam}      value=Boolean |
    {FloatRestParam}        value = FLOAT |
    {ContentProviderRestParam}  value = ContentProviderPath
;

// POST as default for InvokeDefinition
enum RESTMethod:
	POST = 'POST' | GET = 'GET' | PUT = 'PUT' | DELETE = 'DELETE'
;


/////////////////////////////////////////////
// Controller Layer => Concatenated String
/////////////////////////////////////////////

/**
 * Each Value has a string representation:
 * <ul>
 *   <li>INT: 1 => "1"</li>
 *   <li>FLOAT: 1.0 => "1.0"</li>
 *   <li>STRING: "str" => "str"</li>
 *   <li>BOOLEAN: true => "true"</li>
 *   <li>DATE: 2000-01-01 => "2000-01-01"</li>
 *   <li>TIME: 00:00:00Z => "00:00:00Z"</li>
 *   <li>DATE_TIME: 2000-01-01T00:00:00Z => "2000-01-01T00:00:00Z"</li>
 *   <li>Entity => "Entity"</li>
 * </ul>
 *
 * TODO - consider to use a human readable format for the string representation of DATE, TIME and DATE_TIME
 */
ConcatenatedString returns SimpleExpression:
	StringPartial ({ConcatenatedString.leftString=current} OP_STRING_CONCAT rightString=StringPartial)*
;

StringPartial returns SimpleExpression:
	=>MathExpression |
	'(' ConcatenatedString ')' |
	{StringVal} value = STRING |
	{BooleanVal} value = Boolean |
	{DateVal} value = DATE |
	{TimeVal} value = TIME |
	{DateTimeVal} value = DATE_TIME
;


/////////////////////////////////////////////
// Controller Layer => Math Expressions
/////////////////////////////////////////////

MathLiteral returns SimpleExpression:
	=>AbstractContentProviderPath |
	AbstractProviderReference |
	AbstractViewGUIElementRef |
	{IntVal} value = INT |
	{FloatVal} value = FLOAT |
	{SensorVal} value = SENSOR //TODO
;

AdditionSubtraction returns SimpleExpression:
	MultiplicationDivision (({Plus.leftOperand=current} OP_MATH_PLUS | {Minus.leftOperand=current} OP_MATH_MINUS) rightOperand=MultiplicationDivision)*
;

MultiplicationDivision returns SimpleExpression:
	MathSubExpression (({Mult.leftOperand=current} OP_MATH_MULT | {Div.leftOperand=current} OP_MATH_DIV) rightOperand=MathSubExpression)*
;

MathSubExpression returns SimpleExpression:
	MathLiteral | '(' AdditionSubtraction ')'
;

MathExpression returns SimpleExpression:
	AdditionSubtraction
;


/////////////////////////////////////
/////////////////////////////////////
// Model layer
/////////////////////////////////////
/////////////////////////////////////

/*
 * The root Model element that contains all ModelElements.
 */
Model:
	 modelElements += ModelElement+
;

/*
 * The ModelElement is the super type of all possible ModelElements.
 */
ModelElement:
	 Entity | Enum
;

/*
 * An Enum allows the user to define a list of STRING values, stored
 * in the enumBody.
 */
Enum:
	'enum' name = EID '{'
		(enumBody = EnumBody)?
	'}'
;

/*
 * An EnumBody allows the user to define a list of STRING values.
 */
EnumBody:
	elements += STRING (',' elements += STRING)*
;

/*
 * An Entity allows the user to define a type,
 * that will be used as data transfer object.
 * The user can provide a list of Attributes.
 */
Entity:
	'entity' name = EID '{'
		attributes += Attribute*
	'}'
;

/*
 * Each Attribute has a name and an AttributeType.
 * Additionally the user can provide further
 * information to an Attribute, namely an
 * extendedName and a description. These further
 * information will be used by the
 * AutoGeneratedContentElement to generate a
 * label and a tooltip.
 */
Attribute:
	name = EID ':' type = AttributeType ('{'
		('name' extendedName = STRING)?
		('description' description = STRING)?
	'}')?
;

/*
 * AttributeType is the super type of all possible AttributeTypes.
 * These can be besides SimpleDataTypes a references to an already
 * defined ModelElement or an implicit Enum declaration.
 */
AttributeType:
	{ReferencedType} element = [ModelElement | QUALIFIED_NAME]	many ?= BRACKETS? ('(' (params += ReferencedTypeParam (',' params += ReferencedTypeParam)*)? ')')? |
	{IntegerType} 'integer'										many ?= BRACKETS? ('(' (params += IntegerTypeParam (',' params += IntegerTypeParam)*)? ')')? |
	{FloatType} 'float'											many ?= BRACKETS? ('(' (params += FloatTypeParam (',' params += FloatTypeParam)*)? ')')? |
	{StringType} 'string'										many ?= BRACKETS? ('(' (params += StringTypeParam (',' params += StringTypeParam)*)? ')')? |
	{BooleanType} 'boolean'										many ?= BRACKETS? ('(' (params += BooleanTypeParam (',' params += BooleanTypeParam)*)? ')')? |
	{DateType} 'date'											many ?= BRACKETS? ('(' (params += DateTypeParam (',' params += DateTypeParam)*)? ')')? |
	{TimeType} 'time'											many ?= BRACKETS? ('(' (params += TimeTypeParam (',' params += TimeTypeParam)*)? ')')? |
	{DateTimeType} 'datetime'									many ?= BRACKETS? ('(' (params += DateTimeTypeParam (',' params += DateTimeTypeParam)*)? ')')? |
	{FileType} 'file'										    many ?= BRACKETS? ('(' (params += FileTypeParam (',' params += FileTypeParam)*)? ')')? |

	//Sensoren mit keinem weiteren Achse/Dimension
	{SensorType} 'sensor'										many ?= BRACKETS? '(' (params += SensorTypeParam')') |
	//Sensoren mit weiteren AusprÃ¤gungen
	{SensorType} 'sensor'										many ?= BRACKETS? ('(' (params += SensorTypeParam2 (',' params += SensorAxis))')') |


	// EnumType => Transformed to explicit Enum (=> ReferencedType) after preprocessing
	{EnumType} '{' (enumBody = EnumBody)? '}'					many ?= BRACKETS? ('(' (params += EnumTypeParam (',' params += EnumTypeParam)*)? ')')?
;

/*
 * The parser rule BRACKETS defines how square brackets look like.
 * BRACKETS can be annotated to an AttributeType to declare the
 * Attribute to have a one to many relation.
 */
BRACKETS:
	'[' ']'
;


/////////////////////////////////////
// Attribute parameter definitions
/////////////////////////////////////

/*
 * AttributeTypeParam is used to define a common super type of all specific AttributeTypeParams.
 *
 * The AttributeTypeParam is not used in the language but will be used by the generators. Therefore
 * it can be seen as a workaround to manipulate the meta model, that will be built by Xtext.
 */
AttributeTypeParam:
	ReferencedTypeParam | IntegerTypeParam | FloatTypeParam | StringTypeParam | BooleanTypeParam | DateTypeParam | TimeTypeParam | DateTimeTypeParam | EnumTypeParam | FileTypeParam | SensorTypeParam
;

/*
 * ReferencedTypeParam is a super type of all possible parameters of referenced Attributes.
 * The value being optional is the only parameter. This parameter will be used to generate a validator.
 *
 * The parser cannot distinguish cross-references to different parsing rules.
 * Thus, it is necessary to link the common super type ModelElement. Validators have to assure that
 * enum specific parameters cannot be assigned to referenced entities and vice versa.
 */
ReferencedTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrEnumDefault} 'default' value = STRING // enum specific
;

/*
 * IntegerTypeParam is a super type of all
 * possible parameters of integer Attributes.
 * Besides the value being optional, it is
 * possible to mark it as the identifier of
 * the entity and to provide a minimum and
 * a maximum value. These parameters will
 * be used to generate validators.
 */
IntegerTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrIdentifier} identifier ?= 'identifier' |
	{AttrIntDefault} 'default' value = INT |
	{AttrIntMax} 'max' max = INT |
	{AttrIntMin} 'min' min = INT
;

/*
 * FloatTypeParam is a super type of all possible
 * parameters of float Attributes. Besides
 * the value being optional, it is possible
 * to provide a minimum and a maximum value.
 * These parameters will be used to generate validators.
 */
FloatTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrFloatDefault} 'default' value = FLOAT |
	{AttrFloatMax} 'max' max = FLOAT |
	{AttrFloatMin} 'min' min = FLOAT
;

/* SensorTypeParam
 * SensorTypeParam is a super type of all possible
 * parameters of sensor Attributes. The selection
 * of an explicit sensor (e.g. heartrate) is
 * mandatory.
 */
SensorTypeParam:
	{AttrSensorTyp} heartrate ?= 'Pulsmesser' |
	{AttrSensorTyp} proximity ?= 'Annaeherungsschalter'
;
SensorTypeParam2:
	{AttrSensorTyp} accelerometer ?= 'Beschleunigungssensor' |
	{AttrSensorTyp} gyroskop ?= 'Gyroskop'
;

/* SensorAxis
 * SensorAxis provides the axis X,Y,Z which are
 * relevant for the accelerometer and
 * gyroscope.
 */
SensorAxis:
	{AttrSensorAxis} x ?= 'x' |
	{AttrSensorAxis} y ?= 'y' |
	{AttrSensorAxis} z ?= 'z'
;

/*
 * StringTypeParam is a super type of all possible
 * parameters of string Attributes. Besides the
 * value being optional, it is possible to mark
 * it as the identifier of the entity and to
 * provide a minimum and a maximum string length.
 * These parameters will be used to generate validators.
 */
StringTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrIdentifier} identifier ?= 'identifier' |
	{AttrStringDefault} 'default' value = STRING |
	{AttrStringMax} 'maxLength' max = INT |
	{AttrStringMin} 'minLength' min = INT
;

/*
 * BooleanTypeParam is a super type of all
 * possible parameters of boolean Attributes.
 * The value being optional is the only
 * parameter. This parameter will be used
 * to generate a validator.
 */
BooleanTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrBooleanDefault} 'default' value = Boolean
;

/*
 * FileTypeParam is a super type of all
 * possible parameters of file Attributes.
 * The value being optional is the only
 * parameter.
 */
FileTypeParam:
	{AttrIsOptional} optional ?= 'optional'
;

/*
 * DateTypeParam is a super type of all
 * possible parameters of date Attributes.
 * Besides the value being optional, it
 * is possible to provide a minimum and a
 * maximum value. These parameters will
 * be used to generate validators.
 */
DateTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrDateDefault} 'default' value = DATE |
	{AttrDateMax} 'max' max = DATE |
	{AttrDateMin} 'min' min = DATE
;

/*
 * TimeTypeParam is a super type of all
 * possible parameters of time Attributes.
 * Besides the value being optional, it
 * is possible to provide a minimum and a
 * maximum value. These parameters will
 * be used to generate validators.
 */
TimeTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrTimeDefault} 'default' value = TIME |
	{AttrTimeMax} 'max' max = TIME |
	{AttrTimeMin} 'min' min = TIME
;

/*
 * DateTimeTypeParam is a super type of
 * all possible parameters of datetime
 * Attributes. Besides the value being
 * optional, it is possible to provide
 * a minimum and a maximum value. These
 * parameters will be used to generate
 * validators.
 */
DateTimeTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrDateTimeDefault} 'default' value = DATE_TIME |
	{AttrDateTimeMax} 'max' max = DATE_TIME |
	{AttrDateTimeMin} 'min' min = DATE_TIME
;

/*
 * ReferencedTypeParam is a super type of all possible parameters of referenced
 * Attributes. The value being optional is the only parameter. This parameter
 * will be used to generate a validator.
 */
EnumTypeParam:
	{AttrIsOptional} optional ?= 'optional' |
	{AttrEnumDefault} 'default' value = STRING
;


/////////////////////////////////////
/////////////////////////////////////
// New Workflow Concept
/////////////////////////////////////
/////////////////////////////////////

/*
 * A workflow allows to construct multiple applications based on WorkflowElements and to specify apps that
 * consist of these workflowelements.
 */
Workflow:
	(workflowElementEntries += WorkflowElementEntry+) &
	(apps += App+)
;

/*
 * WorkflowElements provide reusable functionality across applications.
 * They allow the construction of a directed graph via events. For every event,
 * 0 to n Workflowelements can be started
 */
WorkflowElementEntry:
	'WorkflowElement' workflowElement=[WorkflowElement] ('('invokable ?= 'invokable' (eventDesc=STRING)?')')?
	firedEvents += FireEventEntry+
;

FireEventEntry:
	'fires' event = [WorkflowEvent] '{'
			('start' startedWorkflowElement = [WorkflowElement] |
			'end' endWorkflow?='workflow')
		'}'
;
/*
 *  Workflowevents are used for the navigation in the graph of workflowelements
 */
WorkflowEvent:
	name=EID
;

/*
 * The application bundles multiple workflow elements and describes general app information.
 */
App:
	'App' name=EID '{'
		('WorkflowElements' '{'
			  workflowElements += WorkflowElementReference (',' workflowElements += WorkflowElementReference)*
		'}') &
		('appName' appName = STRING) &
		('defaultConnection' defaultConnection = [RemoteConnection])?
	'}'
;

/*
 * When referenced in an App, WorkflowElements can be specified as startable from the application's start screen.
 * The alias determines the corresponding button label.
 */
WorkflowElementReference:
	workflowElementReference = [WorkflowElement] ( '(' startable ?= 'startable:' alias=STRING ')' )?
;


/////////////////////////////////////
/////////////////////////////////////
// Terminal and data type rules
/////////////////////////////////////
/////////////////////////////////////

/**
 * Definition of a date. A string that conforms of the following format is expected:
 * YYYY-MM-DD
 */
DATE returns ecore::EDate:
	DATE_FORMAT
;

/**
 * Definition of the time. A string that conforms of the following format is expected:
 * hh:mm:ss[(+|-)hh[:mm]] or hh:mm:ss[Z]
 */
TIME returns ecore::EDate:
	TIME_FORMAT
;

/**
 * Definition of date and time. A string that conforms ISO 8601 is expected.
 * YYYY-MM-DDThh:mm:ss[(+|-)hh[:mm]] or
 * YYYY-MM-DDThh:mm:ss[Z]
 */
DATE_TIME returns ecore::EDate:
	DATE_TIME_FORMAT
;

/**
 * Float #.#
 */
FLOAT returns ecore::EDouble:
	INT '.' INT
;

/**
 * TODO Sensor #.#
 */
SENSOR returns ecore::EDouble:
	INT "," INT
;

/**
 * Percent #%
 */
PERCENT returns ecore::EInt:
	INT '%'
;

/*
 * Extended, keyword insensitive ID. Using the EID allows to use a known keyword as an ID.
 *
 * TODO Find all keywords that do not break the grammar
 */
EID:
	//location content provider fields
	'latitude' | 'longitude' | 'altitude' | 'city' | 'street' | 'number' | 'postalCode' | 'country' | 'province' |

	// font styles
	'bold' | 'italic' | 'normal' |

	// colors
	'aqua' | 'black' | 'blue' | 'gray' | 'green' | 'lime' | 'maroon' | 'navy' | 'olive' | 'purple' |
	'red' | 'silver' | 'white' | 'yellow' |

	// other keywords
	'Location' |

	// arbitrary ID
	ID

	//'action' | 'actions' |
	//'silent' | 'event' | 'valid' | 'empty' | 'filled' | 'enum' | 'entity' | 'name' |
	//'description' | 'optional' | 'tabTitle' | 'tabIcon' |
	//'displayAll' | 'fontSize' | 'color' | 'textStyle' |
	//	'only' | 'style' | 'text' | 'height' | 'width' |
	//	'src' | 'columns' | 'rows' | 'horizontal' | 'vertical' | 'onLongClick' |
	//	'onRightSwipe' | 'onWrongValidation' | 'onConnectionLost' | 'validator' |
	//	'connection' | 'model' | 'attributes' | 'message' | 'format' | 'regEx' | 'max' | 'min' |
	//	'maxLength' | 'minLength' | 'main' | 'appName' | 'appVersion' | 'defaultConnection' | 'startView' | 'modelVersion' |
	//	'uri' | 'password' | 'user' | 'key' |
	//	'cache' | 'providerType' | 'local' | 'filter' | 'where' | 'allowedOperations' | 'first' |
	//	'save' | 'load' | 'remove' | 'processChain' | 'step' |
	//	'forwardMessage' | 'backwardMessage' | 'validator' | 'validators' |
	//	'unbind' | 'map' | 'unmap' | 'all' | 'call' | 'onTouch' | 'onLeftSwipe' | 'use' | 'for' | 'to' | 'bind' | 'on' | 'from'
	//	'forwardCondition' | 'forwardOnEvent' | 'backwardCondition' | 'backwardOnEvent' |'view' | 'onInitialized' | 'defaultProcessChain' |
	//	'integer' | 'float' | 'string' | 'boolean' | 'date' | 'time' | 'timestamp' | 'remoteConnection' |  'contentProvider' |
;

/**
 * Qualified names of the form
 * <code>ID (.ID)*</code>
 */
QUALIFIED_NAME:
	EID ('.' EID)*
;

/**
 * Override default terminal rule ID to not allow two underscores (__) at the beginning of the ID
 * as such IDs are used internally by the pre-processor.
 */
terminal ID:
	'^'?('a'..'z'|'A'..'Z'|'_') (('a'..'z'|'A'..'Z'|'0'..'9') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*)?
;

/**
 * Hexadecimal color definitions of the form #ffffff or #ffffffff.
 * In the 8-digit definition the leading two digits specify the (optional) alpha channel.
 */
terminal HEX_COLOR:
	'#'
	(('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f'))?
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
	('0'..'9'|'A'..'F'|'a'..'f') ('0'..'9'|'A'..'F'|'a'..'f')
;

/**
 * Definition of a date that conforms the format YYYY-MM-dd
 */
terminal DATE_FORMAT:
	('0'..'9')('0'..'9')('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')
;

/**
 * Definition of a time that conforms the format
 * hh:mm:ss[(+|-)hh[:mm]] or hh:mm:ss[Z]
 */
terminal TIME_FORMAT:
	('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9') ('Z' | (('+'|'-')('0'..'9')('0'..'9') (':'('0'..'9')('0'..'9'))?))?
;

/**
 * Definition of a time that conforms the format
 * YYYY-MM-ddThh:mm:ss[(+|-)hh[:mm]] or YYYY-MM-ddThh:mm:ss[Z]
 */
terminal DATE_TIME_FORMAT:
	DATE_FORMAT 'T' TIME_FORMAT
;


//////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////

OP_MATH_PLUS:
	'+'
;

OP_MATH_MINUS:
	'-'
;

OP_MATH_MULT:
	'*'
;

OP_MATH_DIV:
	'/'
;

OP_STRING_CONCAT:
	'&'
;

OP_CONDITION_AND:
	'and'
;

OP_CONDITION_OR:
	'or'
;

OP_CONDITION_NOT:
	'not'
;

/*
 * Define all operators that can be used to compare values in conditional expressions.
 */
enum Operator:
	EQUALS = 'equals' | GREATER = '>' | SMALLER = '<' | GREATER_OR_EQUAL = '>=' | SMALLER_OR_EQUAL = '<='
;

/*
 * Boolean lists all possible Boolean values.
 */
enum Boolean:
	TRUE='true' | FALSE='false'
;
